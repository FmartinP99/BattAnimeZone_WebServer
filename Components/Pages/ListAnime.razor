@using BattAnimeZone.Services
@using BattAnimeZone.Components.Models.Genre
@using BattAnimeZone.Components.Models.Anime
@inject NavigationManager navManager
@inject AnimeService animeService
<link rel="stylesheet" href="/ListAnime.css" />
@page "/animelist"

<SearchBar></SearchBar>

<RadzenStack class="rz-p-0 rz-p-md-12">

    <RadzenCard Style="background:transparent;">
        <RadzenPickList @bind-Source="@SourceGenres" @bind-Target="@TargetGenres" Style="height:300px; width:100%; background:transparent;" Orientation="@orientation"
                        TextProperty="@nameof(AnimeGenre.Name)" AllowFiltering="@allowFilter" Multiple="@multiple" ShowHeader="@showHeader"
                        ButtonGap="@gap" ButtonJustifyContent="@justifyContent" ButtonStyle="@style" ButtonSize="@size" ButtonShade="@shade" ButtonVariant="@variant">
            <SourceHeader>
                Genres:
            </SourceHeader>
            <TargetHeader>
                Selected Genres:
            </TargetHeader>
            <Template>
                @context.Name
            </Template>
        </RadzenPickList>
    </RadzenCard>

    <div class="rz-p-sm-12 dropdownDiv">
        <RadzenColumn class="rz-text-align-end">
        <RadzenLabel Text="Select Values  (OR search)" Component="DropDownMultipleChips" Style="margin-right: 8px; vertical-align: middle;" />
        <RadzenDropDown class="rzdropdown" @bind-Value=@selected_medias Data=@media_types Name="DropDownMultipleChips"
                        Multiple=true AllowClear=true Placeholder="Select Media Types" Chips=true Style="width: 100%; max-width: 400px;" />
        </RadzenColumn>
        <RadzenColumn Style="margin-top:30px;" class="rz-text-align-end">
        <OrderComponent animes="searched_animes" AnimesChanged="OnAnimesChanged"></OrderComponent>
        </RadzenColumn>
    </div>




    <RadzenButton Click="Search" Style="background-image: linear-gradient(to right, #5832dd,#5025ce,#5832dd,#5025ce,#5832dd);">FILTER ANIMES</RadzenButton>
</RadzenStack>



<RadzenPager Style="overflow-x: clip; max-width: 75vw;" PagingSummaryFormat="@pagingSummaryFormat" ShowPagingSummary="true" HorizontalAlign="HorizontalAlign.Left" PageNumbersCount=@pagenumcount PageSize=@pageSize Count="count" PageChanged="@PageChanged" />

@if (searched_animes.Count > 0){



    @foreach (Anime anime in animes_per_page)
    {
        <RadzenRow @onclick=@(() => NavigateTo(anime.Mal_id)) Style="height:100px; margin-bottom: 30px;">
            <RadzenColumn Style="max-width:100px; ">
                <RadzenImage Style="max-width:100px; max-height:100px;" Path="@anime.Image_large_webp_url"></RadzenImage>
            </RadzenColumn>
            <RadzenColumn Style="max-width:200px;">
                English Name: <br> @anime.Title_english
            </RadzenColumn>
            <RadzenColumn Style="max-width:200px;">
                Japanese name: <br> @anime.Title_japanese
            </RadzenColumn>
            <RadzenColumn Style="max-width:100px;">
                Type: <br> @anime.Media_type
            </RadzenColumn>
            <RadzenColumn Style="max-width:100px;">
                Episodes: <br> @anime.Episodes
            </RadzenColumn>
            <RadzenColumn Style="max-width:100px;">
                Score: <br> @anime.Score
            </RadzenColumn>
            <RadzenColumn Style="max-width:100px;">
                Year: <br> @anime.Year
            </RadzenColumn>
            <RadzenColumn Style="max-width:100px;">
                Status: <br> @anime.Status
            </RadzenColumn>
        </RadzenRow>
    }
}


@code {
    Dictionary<int, int> animeCountPerGenre = new Dictionary<int, int>();

    JustifyContent justifyContent = JustifyContent.Center;
    Variant variant = Variant.Outlined;
    ButtonStyle style = ButtonStyle.Secondary;
    Shade shade = Shade.Default;
    ButtonSize size = ButtonSize.Medium;
    Orientation orientation = Orientation.Horizontal;

    string gap = "12px";
    bool allowFilter = true;
    bool multiple = true;
    bool showHeader = true;

    IEnumerable<AnimeGenre> _sourceGenres = new List<AnimeGenre>();
    IEnumerable<AnimeGenre> SourceGenres
    {
        get
        {
            return _sourceGenres;
        }
        set
        {
            if (value != null)
            {
                _sourceGenres = value;
            }
            else
            {
                _sourceGenres = new List<AnimeGenre>();
            }
        }
    }

    IEnumerable<AnimeGenre> _targetGenres = new List<AnimeGenre>();
    IEnumerable<AnimeGenre> TargetGenres
    {
        get
        {
            return _targetGenres;
        }
        set
        {
            if (value != null)
            {
                _targetGenres = value;
                foreach(var tar in value)
                {
                    Console.WriteLine(tar.Name);
                }
            }
            else
            {
                _targetGenres = new List<AnimeGenre>();
            }
        }
    }





    Dictionary<int, HashSet<int>> animesPerGenreIDs;
    List<Anime> searched_animes = new List<Anime>();

    Dictionary<string, HashSet<int>> animesPerMediaTypeIDs;
    List<string> media_types;
    List<string> selected_medias = new List<string>();


    IEnumerable<Anime> animes_per_page = new List<Anime>();
    string pagingSummaryFormat = "Displaying page {0} of {1} (total {2} records)";
    int pageSize = 20;
    int count;
    int pageNumber;
    int pagenumcount = 15;
    int last_skip = 0;



    protected override async Task OnInitializedAsync()
    {

        media_types = await animeService.GetMediaTypes();
        Dictionary<int, AnimeGenre> ang = await animeService.GetGenres();
        SourceGenres = ang.Values.ToList();
        animesPerGenreIDs = await animeService.GetAnimesPerGenreIds();

        animeCountPerGenre = animesPerGenreIDs.ToDictionary(
            kvp => kvp.Key,
            kvp => kvp.Value.Count
        );

        SourceGenres = SourceGenres
            .OrderByDescending(genre => animeCountPerGenre.ContainsKey(genre.Mal_id) ? animeCountPerGenre[genre.Mal_id] : 0)
            .Where(genre => animeCountPerGenre.ContainsKey(genre.Mal_id) && animeCountPerGenre[genre.Mal_id] != 0)
            .ToList();

        animesPerMediaTypeIDs = await animeService.GetAnimesPerMediaTypeIds();

        await base.OnInitializedAsync();

    }


    protected async Task<HashSet<int>> SearchByGenres()
    {
        HashSet<int> found_animes = new HashSet<int>();
        List<AnimeGenre> targetList = TargetGenres.ToList();
        int first_index = targetList[0].Mal_id;
        found_animes = new HashSet<int>(animesPerGenreIDs[first_index]);
        for(int i=1; i<targetList.Count; i++)
        {
            HashSet<int> curr_animes = animesPerGenreIDs[targetList[i].Mal_id];
            found_animes.IntersectWith(curr_animes);
        }

        return found_animes;

    }

    protected async Task<HashSet<int>> SearchByMediaTypes()
    {
        HashSet<int> commonElements = new HashSet<int>(animesPerMediaTypeIDs[selected_medias[0]]);
        if (selected_medias.Count > 1)
        {
            foreach (string key in selected_medias.Skip(1))
            {
                commonElements.UnionWith(animesPerMediaTypeIDs[key]);
            }
        }
        return commonElements;
    }


    protected async Task Search()
    {
        HashSet<int> found_animes = new HashSet<int>();

        List<HashSet<int>> found_anime_ids = new List<HashSet<int>>();
        if (!(TargetGenres == null || !TargetGenres.Any()))
            found_anime_ids.Add(await SearchByGenres());
        if (selected_medias != null && selected_medias.Count > 0)
            found_anime_ids.Add(await SearchByMediaTypes());

        if (found_anime_ids.Count > 0)
        {
            found_animes = found_anime_ids[0];
            foreach (HashSet<int> faids in found_anime_ids.Skip(1))
            {
                found_animes.IntersectWith(faids);
            }
        }

        searched_animes = await animeService.GetMultipleAnimes(found_animes);
        searched_animes = searched_animes.OrderByDescending(anim => anim.Score).ToList();
        animes_per_page = searched_animes.Take(pageSize);
        count = searched_animes.Count;
    }

    void PageChanged(PagerEventArgs args)
    {
        animes_per_page = searched_animes.Skip(args.Skip).Take(args.Top);
        last_skip = args.Skip;
    }

    private void OnAnimesChanged(List<Anime> updatedAnimes)
    {
        Console.WriteLine("OnAnimesChanged called");
        searched_animes = updatedAnimes;
        animes_per_page = searched_animes.Skip(last_skip).Take(pageSize);
        StateHasChanged(); 
    }

    protected async void NavigateTo(int mal_id)
    {
        navManager.NavigateTo($"/anime/{mal_id}");
    }

}
